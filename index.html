<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Material Flow Sankey Diagram</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1f2937;
        }

        /* Styling for the links (flows) in the Sankey diagram */
        .link {
            fill: none;
            stroke-opacity: 0.5;
        }

        .link:hover {
            stroke-opacity: 0.8;
        }

        /* Styling for the nodes in the Sankey diagram */
        .node text {
            pointer-events: none;
            font-size: 12px;
            font-weight: 600;
            text-shadow: 0 1px 0 #fff;
        }

        /* Custom tooltip style */
        .sankey-tooltip {
            position: absolute;
            text-align: center;
            padding: 8px 12px;
            font-size: 14px;
            background: #1f2937;
            color: #ffffff;
            border: 0;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>

<body class="bg-gray-50">

    <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        <div class="bg-white rounded-xl shadow-lg p-6">
            <h1 class="text-2xl font-bold text-gray-800 mb-2">Material Flow Analysis</h1>
            <p class="text-gray-600 mb-6">This Sankey diagram visualizes the material flow and losses based on the
                provided UML diagram. Flow widths are proportional to material quantity. All values are based on an
                initial input of 100 units.</p>

            <div class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <label for="successRate" class="block text-sm font-medium text-gray-700">Adjust Part Success Rate
                    (%):</label>
                <div class="flex items-center mt-1">
                    <input type="range" id="successRate" min="0" max="100" value="80"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    <span id="successRateValue" class="ml-4 font-semibold text-blue-700 w-12 text-center">80%</span>
                </div>
                <p class="text-xs text-gray-500 mt-1">Adjust the slider to see how the final product output and waste
                    streams change based on the testing success rate.</p>
            </div>

            <div class="mt-4 text-xs text-gray-500 p-3 bg-gray-100 rounded-md">
                <strong>Note on Circular Flow:</strong> To prevent rendering errors, the circular recycling loop
                (Shredder â†’ Recycled Pellets) has been broken. "Recycled Pellets (Input)" represents material from a
                previous cycle, while "Recycled Pellets (Output)" represents the material recovered from this cycle,
                which is ready for the next one.
            </div>

            <div id="sankey-chart-container" class="w-full overflow-x-auto mt-6">
                <svg id="sankey"></svg>
            </div>
            <div class="sankey-tooltip"></div>
        </div>
    </div>

    <script>
        // --- Data Processing and Initial Setup ---

        // This is the core data structure for the Sankey diagram.
        // It's derived from your draw.io XML. The circular link has been broken
        // by creating separate input and output nodes for recycled pellets.
        const graphData = {
            nodes: [
                // The order here is important and is referenced by the links' source/target index.
                { name: "Virgin Material", color: "#647687" },
                { name: "Recycled Pellets (Input)", color: "#6d8764" },
                { name: "Print Process", color: "#f8cecc" },
                { name: "Printed Actuator", color: "#dae8fc" },
                { name: "Successful Product", color: "#e6f7ff" },
                { name: "Failed Parts", color: "#ffe6cc" },
                { name: "Shredder", color: "#76608a" },
                { name: "Print Loss", color: "#d6d6d6" },
                { name: "Recycling Loss", color: "#d6d6d6" },
                { name: "Recycled Pellets (Output)", color: "#22c55e" } // New node to break the cycle
            ],
            links: [] // Links will be calculated dynamically
        };

        // --- D3 Sankey Drawing Function ---

        function drawSankey(data) {
            const container = d3.select("#sankey-chart-container");
            container.select("svg").selectAll("*").remove(); // Clear previous SVG content

            const containerWidth = parseInt(container.style("width"));
            const height = 500;
            const width = Math.max(containerWidth, 900); // Ensure a minimum width

            const svg = d3.select("#sankey")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMinYMin meet");

            // Configure the Sankey generator
            const sankey = d3.sankey()
                .nodeId(d => d.name)
                .nodeWidth(25)
                .nodePadding(20)
                .nodeAlign(d3.sankeyJustify)
                .extent([[1, 5], [width - 1, height - 10]]);

            // Compute the Sankey layout
            let layout;
            try {
                layout = sankey(data);
            } catch (error) {
                console.error("Error computing Sankey layout:", error);
                // Display an error message to the user
                container.html(`<div class="text-red-600 p-4">Error: Could not generate the diagram. The data may contain a circular reference.</div>`);
                return;
            }
            const { nodes, links } = layout;


            // --- Draw Links (Flows) ---
            const linkGroup = svg.append("g")
                .attr("fill", "none")
                .attr("stroke-opacity", 0.5);

            const link = linkGroup.selectAll("g")
                .data(links)
                .join("g")
                .style("mix-blend-mode", "multiply");

            const gradient = link.append("linearGradient")
                .attr("id", (d, i) => `gradient-${i}`)
                .attr("gradientUnits", "userSpaceOnUse")
                .attr("x1", d => d.source.x1)
                .attr("x2", d => d.target.x0);

            gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", d => d.source.color);

            gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", d => d.target.color);

            link.append("path")
                .attr("class", "link")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", (d, i) => `url(#gradient-${i})`)
                .attr("stroke-width", d => Math.max(1, d.width));

            // --- Tooltip for Links ---
            const tooltip = d3.select(".sankey-tooltip");

            link.on("mouseover", (event, d) => {
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(`${d.source.name} &rarr; ${d.target.name}<br><b>${d.value.toFixed(2)} units</b>`)
                    .style("left", (event.pageX + 15) + "px")
                    .style("top", (event.pageY - 28) + "px");
            }).on("mouseout", () => {
                tooltip.transition().duration(500).style("opacity", 0);
            });

            // --- Draw Nodes ---
            const nodeGroup = svg.append("g")
                .attr("class", "nodes")
                .attr("font-family", "sans-serif")
                .attr("font-size", 10);

            const node = nodeGroup.selectAll("g")
                .data(nodes)
                .join("g");

            node.append("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", d => d.color)
                .attr("stroke", "#374151")
                .attr("stroke-width", 1.5)
                .attr("rx", 4)
                .attr("ry", 4);

            // --- Add Text Labels to Nodes ---
            node.append("text")
                .attr("x", d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
                .text(d => d.name)
                .style("fill", "#111827")
                .style("font-size", "14px")
                .style("font-weight", "600");

            // Add value text inside the node
            node.append("text")
                .attr("x", d => (d.x0 + d.x1) / 2)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "middle")
                .text(d => `${d.value.toFixed(1)}`)
                .style("fill", "#111827")
                .style("font-size", "12px")
                .style("font-weight", "bold");
        }

        // --- Dynamic Calculation Function ---
        function calculateAndDraw(successRate) {
            // successRate is a percentage (e.g., 80)
            const successDecimal = successRate / 100;

            // Define inputs
            const virginInput = 30;
            const recycledInput = 70;
            const totalInput = virginInput + recycledInput;

            // Calculate flows from Print Process
            const toPart = totalInput * 0.90;
            const printLoss = totalInput * 0.10;

            // Calculate flows from Printed Actuator
            const successfulParts = toPart * successDecimal;
            const failedParts = toPart * (1 - successDecimal);

            // Calculate flows from Shredder
            const toRecycledPellets = failedParts * 0.90;
            const recyclingLoss = failedParts * 0.10;

            // Update the links data with the corrected flow
            graphData.links = [
                { source: "Virgin Material", target: "Print Process", value: virginInput },
                { source: "Recycled Pellets (Input)", target: "Print Process", value: recycledInput },
                { source: "Print Process", target: "Printed Actuator", value: toPart },
                { source: "Print Process", target: "Print Loss", value: printLoss },
                { source: "Printed Actuator", target: "Successful Product", value: successfulParts },
                { source: "Printed Actuator", target: "Failed Parts", value: failedParts },
                { source: "Failed Parts", target: "Shredder", value: failedParts },
                // Corrected link to break the cycle
                { source: "Shredder", target: "Recycled Pellets (Output)", value: toRecycledPellets },
                { source: "Shredder", target: "Recycling Loss", value: recyclingLoss }
            ];

            // Filter out any links with a value of 0 to prevent rendering errors
            const filteredData = {
                nodes: graphData.nodes,
                links: graphData.links.filter(link => link.value > 0.001)
            };

            drawSankey(filteredData);
        }

        // --- Event Listeners ---
        const successRateSlider = document.getElementById('successRate');
        const successRateValueSpan = document.getElementById('successRateValue');

        successRateSlider.addEventListener('input', (event) => {
            const newRate = parseInt(event.target.value);
            successRateValueSpan.textContent = `${newRate}%`;
            calculateAndDraw(newRate);
        });

        // Initial draw
        calculateAndDraw(parseInt(successRateSlider.value));

        // Redraw on window resize
        window.addEventListener('resize', () => {
            calculateAndDraw(parseInt(successRateSlider.value));
        });

    </script>

</body>

</html>